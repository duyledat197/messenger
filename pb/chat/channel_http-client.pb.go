// Code generated by protoc-gen-http-client. DO NOT EDIT.
// version: 3.14.0
// source: chat/channel.proto

package chat

import (
	"context"
	"fmt"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	"net/http"
	"net/url"
	util "openmyth/messgener/util"
	httpclient "openmyth/messgener/util/http_client"
)

// HTTPClient is a http client for the ChannelService service
type ChannelServiceHTTPClient struct {
	BaseURL      string
	roundTripper http.RoundTripper
}

func NewChannelServiceHTTPClient(baseURL string) *ChannelServiceHTTPClient {
	return &ChannelServiceHTTPClient{
		BaseURL:      baseURL,
		roundTripper: httpclient.NewRoundTripper(),
	}
}

// SearchChannelByName is a http call method for the ChannelService service
func (c *ChannelServiceHTTPClient) SearchChannelByName(ctx context.Context, reqData *SearchChannelByNameRequest) (*SearchChannelByNameResponse, error) {
	path, err := url.JoinPath(c.BaseURL, "/v1/channels/search")
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, fmt.Errorf("path is not valid: %w", err).Error())
	}

	reqClient, err := util.EncodeHTTPRequest(ctx, path, "GET", reqData)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, fmt.Errorf("unable to encode http request: %w", err).Error())
	}
	client := http.Client{Transport: c.roundTripper}
	resp, err := client.Do(reqClient)
	if err != nil {
		return nil, status.Errorf(codes.Internal, fmt.Errorf("unable to request: %w", err).Error())
	}

	return util.DecodeHTTPResponse[SearchChannelByNameResponse](resp)
}

// GetListChannel is a http call method for the ChannelService service
func (c *ChannelServiceHTTPClient) GetListChannel(ctx context.Context, reqData *GetListChannelRequest) (*GetListChannelResponse, error) {
	path, err := url.JoinPath(c.BaseURL, "/v1/channels")
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, fmt.Errorf("path is not valid: %w", err).Error())
	}

	reqClient, err := util.EncodeHTTPRequest(ctx, path, "GET", reqData)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, fmt.Errorf("unable to encode http request: %w", err).Error())
	}
	client := http.Client{Transport: c.roundTripper}
	resp, err := client.Do(reqClient)
	if err != nil {
		return nil, status.Errorf(codes.Internal, fmt.Errorf("unable to request: %w", err).Error())
	}

	return util.DecodeHTTPResponse[GetListChannelResponse](resp)
}
